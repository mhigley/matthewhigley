{"version":3,"sources":["../../../src/internal-plugins/query-runner/page-query-runner.js"],"names":["_","require","queue","store","emitter","queuedDirtyActions","active","running","runQueriesForPathnamesQueue","Set","exports","queueQueryForPathname","pathname","add","runInitialQueries","runQueries","initial","uniq","a","payload","id","dirtyIds","findDirtyIds","cleanIds","findIdsWithoutDataDependencies","pathnamesToRun","diffedPathnames","intersection","union","clear","runQueriesForPathnames","on","action","push","runQueuedActions","length","seenIdsWithoutDataDependencies","filter","p","path","state","getState","allTrackedIds","flatten","concat","values","componentDataDependencies","nodes","connections","notTrackedIds","difference","Array","from","pages","staticQueryComponents","map","c","jsonName","pathnames","staticQueries","slice","pageQueries","forEach","staticQueryComponent","get","queryJob","hash","query","componentPath","context","didNotQueueItems","page","components","isPage","Promise","resolve","onDrain","removeListener","actions","uniqDirties","reduce","node","internal","type","compact"],"mappings":"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","sourcesContent":["// @flow\n\nimport type { QueryJob } from \"../query-runner\"\n\n/**\n * Jobs of this module\n * - Ensure on bootstrap that all invalid page queries are run and report\n *   when this is done\n * - Watch for when a page's query is invalidated and re-run it.\n */\n\nconst _ = require(`lodash`)\n\nconst queue = require(`./query-queue`)\nconst { store, emitter } = require(`../../redux`)\n\nlet queuedDirtyActions = []\n\nlet active = false\nlet running = false\n\nconst runQueriesForPathnamesQueue = new Set()\nexports.queueQueryForPathname = pathname => {\n  runQueriesForPathnamesQueue.add(pathname)\n}\n\n// Do initial run of graphql queries during bootstrap.\n// Afterwards we listen \"API_RUNNING_QUEUE_EMPTY\" and check\n// for dirty nodes before running queries.\nexports.runInitialQueries = async () => {\n  active = true\n  await runQueries(true)\n  return\n}\n\nconst runQueries = async (initial = false) => {\n  // Don't run queries until bootstrap gets to \"run graphql queries\"\n  if (!active) {\n    return\n  }\n\n  // Find paths dependent on dirty nodes\n  queuedDirtyActions = _.uniq(queuedDirtyActions, a => a.payload.id)\n  const dirtyIds = findDirtyIds(queuedDirtyActions)\n  queuedDirtyActions = []\n\n  // Find ids without data dependencies (i.e. no queries have been run for\n  // them before) and run them.\n  const cleanIds = findIdsWithoutDataDependencies()\n\n  // Construct paths for all queries to run\n  let pathnamesToRun = _.uniq([...dirtyIds, ...cleanIds])\n\n  // If this is the initial run, remove pathnames from `runQueriesForPathnamesQueue`\n  // if they're also not in the dirtyIds or cleanIds.\n  //\n  // We do this because the page component reducer/machine always\n  // adds pages to runQueriesForPathnamesQueue but during bootstrap\n  // we may not want to run those page queries if their data hasn't\n  // changed since the last time we ran Gatsby.\n  let diffedPathnames = [...runQueriesForPathnamesQueue]\n  if (initial) {\n    diffedPathnames = _.intersection(\n      [...runQueriesForPathnamesQueue],\n      pathnamesToRun\n    )\n  }\n\n  // Combine.\n  pathnamesToRun = _.union(diffedPathnames, pathnamesToRun)\n\n  runQueriesForPathnamesQueue.clear()\n\n  // Run these paths\n  await runQueriesForPathnames(pathnamesToRun)\n  return\n}\n\nexports.runQueries = runQueries\n\nemitter.on(`CREATE_NODE`, action => {\n  queuedDirtyActions.push(action)\n})\n\nemitter.on(`DELETE_NODE`, action => {\n  queuedDirtyActions.push({ payload: action.payload })\n})\n\nconst runQueuedActions = async () => {\n  if (active && !running) {\n    try {\n      running = true\n      await runQueries()\n    } finally {\n      running = false\n      if (queuedDirtyActions.length > 0) {\n        runQueuedActions()\n      }\n    }\n  }\n}\nexports.runQueuedActions = runQueuedActions\n\n// Wait until all plugins have finished running (e.g. various\n// transformer plugins) before running queries so we don't\n// query things in a 1/2 finished state.\nemitter.on(`API_RUNNING_QUEUE_EMPTY`, runQueuedActions)\n\nlet seenIdsWithoutDataDependencies = []\n\n// Remove pages from seenIdsWithoutDataDependencies when they're deleted\n// so their query will be run again if they're created again.\nemitter.on(`DELETE_PAGE`, action => {\n  seenIdsWithoutDataDependencies = seenIdsWithoutDataDependencies.filter(\n    p => p !== action.payload.path\n  )\n})\n\nconst findIdsWithoutDataDependencies = () => {\n  const state = store.getState()\n  const allTrackedIds = _.uniq(\n    _.flatten(\n      _.concat(\n        _.values(state.componentDataDependencies.nodes),\n        _.values(state.componentDataDependencies.connections)\n      )\n    )\n  )\n\n  // Get list of paths not already tracked and run the queries for these\n  // paths.\n  const notTrackedIds = _.difference(\n    [\n      ...Array.from(state.pages.values(), p => p.path),\n      ...[...state.staticQueryComponents.values()].map(c => c.jsonName),\n    ],\n    [...allTrackedIds, ...seenIdsWithoutDataDependencies]\n  )\n\n  // Add new IDs to our seen array so we don't keep trying to run queries for them.\n  // Pages without queries can't be tracked.\n  seenIdsWithoutDataDependencies = _.uniq([\n    ...notTrackedIds,\n    ...seenIdsWithoutDataDependencies,\n  ])\n\n  return notTrackedIds\n}\n\nconst runQueriesForPathnames = pathnames => {\n  const staticQueries = pathnames.filter(p => p.slice(0, 4) === `sq--`)\n  const pageQueries = pathnames.filter(p => p.slice(0, 4) !== `sq--`)\n  const state = store.getState()\n\n  staticQueries.forEach(id => {\n    const staticQueryComponent = store.getState().staticQueryComponents.get(id)\n    const queryJob: QueryJob = {\n      id: staticQueryComponent.hash,\n      hash: staticQueryComponent.hash,\n      jsonName: staticQueryComponent.jsonName,\n      query: staticQueryComponent.query,\n      componentPath: staticQueryComponent.componentPath,\n      context: { path: staticQueryComponent.jsonName },\n    }\n    queue.push(queryJob)\n  })\n\n  const pages = state.pages\n  let didNotQueueItems = true\n  pageQueries.forEach(id => {\n    const page = pages.get(id)\n    if (page) {\n      didNotQueueItems = false\n      queue.push(\n        ({\n          id: page.path,\n          jsonName: page.jsonName,\n          query: store.getState().components.get(page.componentPath).query,\n          isPage: true,\n          componentPath: page.componentPath,\n          context: {\n            ...page,\n            ...page.context,\n          },\n        }: QueryJob)\n      )\n    }\n  })\n\n  if (didNotQueueItems || !pathnames || pathnames.length === 0) {\n    return Promise.resolve()\n  }\n\n  return new Promise(resolve => {\n    const onDrain = () => {\n      queue.removeListener(`drain`, onDrain)\n      resolve()\n    }\n    queue.on(`drain`, onDrain)\n  })\n}\n\nconst findDirtyIds = actions => {\n  const state = store.getState()\n  const uniqDirties = _.uniq(\n    actions.reduce((dirtyIds, action) => {\n      const node = action.payload\n\n      if (!node || !node.id || !node.internal.type) return dirtyIds\n\n      // Find components that depend on this node so are now dirty.\n      dirtyIds = dirtyIds.concat(state.componentDataDependencies.nodes[node.id])\n\n      // Find connections that depend on this node so are now invalid.\n      dirtyIds = dirtyIds.concat(\n        state.componentDataDependencies.connections[node.internal.type]\n      )\n\n      return _.compact(dirtyIds)\n    }, [])\n  )\n  return uniqDirties\n}\n"],"file":"page-query-runner.js"}