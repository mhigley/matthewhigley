{"version":3,"sources":["../../../src/internal-plugins/query-runner/query-queue.js"],"names":["Queue","require","queryRunner","store","emitter","boundActionCreators","websocketManager","FastMemoryStore","processing","Set","waiting","Map","queueOptions","concurrent","merge","oldTask","newTask","cb","priority","job","activePaths","Array","from","values","id","includes","filter","has","set","process","env","gatsby_executing_command","queue","plObj","callback","state","getState","add","components","component","catch","e","console","log","then","result","delete","push","get","pageQueryRun","path","componentPath","isPage","error","isBootstrapping","pause","on","resume","emit","module","exports"],"mappings":";;AAAA,MAAMA,KAAK,GAAGC,OAAO,CAAE,cAAF,CAArB;;AAEA,MAAMC,WAAW,GAAGD,OAAO,CAAE,gBAAF,CAA3B;;iBAC2BA,OAAO,CAAE,aAAF,C;MAA1BE,K,YAAAA,K;MAAOC,O,YAAAA,O;;kBACiBH,OAAO,CAAE,qBAAF,C;MAA/BI,mB,aAAAA,mB;;AACR,MAAMC,gBAAgB,GAAGL,OAAO,CAAE,+BAAF,CAAhC;;AACA,MAAMM,eAAe,GAAGN,OAAO,CAAE,6BAAF,CAA/B;;AAEA,MAAMO,UAAU,GAAG,IAAIC,GAAJ,EAAnB;AACA,MAAMC,OAAO,GAAG,IAAIC,GAAJ,EAAhB;AAEA,MAAMC,YAAY,GAAG;AACnBC,EAAAA,UAAU,EAAE,CADO;AAEnB;AACAC,EAAAA,KAAK,EAAE,CAACC,OAAD,EAAUC,OAAV,EAAmBC,EAAnB,KAA0B;AAC/BA,IAAAA,EAAE,CAAC,IAAD,EAAOD,OAAP,CAAF;AACD,GALkB;AAMnBE,EAAAA,QAAQ,EAAE,CAACC,GAAD,EAAMF,EAAN,KAAa;AACrB,UAAMG,WAAW,GAAGC,KAAK,CAACC,IAAN,CAAWhB,gBAAgB,CAACc,WAAjB,CAA6BG,MAA7B,EAAX,CAApB;;AACA,QAAIJ,GAAG,CAACK,EAAJ,IAAUJ,WAAW,CAACK,QAAZ,CAAqBN,GAAG,CAACK,EAAzB,CAAd,EAA4C;AAC1CP,MAAAA,EAAE,CAAC,IAAD,EAAO,EAAP,CAAF;AACD,KAFD,MAEO;AACLA,MAAAA,EAAE,CAAC,IAAD,EAAO,CAAP,CAAF;AACD;AACF,GAbkB;AAcnB;AACA;AACA;AACAS,EAAAA,MAAM,EAAE,CAACP,GAAD,EAAMF,EAAN,KAAa;AACnB,QAAIT,UAAU,CAACmB,GAAX,CAAeR,GAAG,CAACK,EAAnB,CAAJ,EAA4B;AAC1Bd,MAAAA,OAAO,CAACkB,GAAR,CAAYT,GAAG,CAACK,EAAhB,EAAoBL,GAApB;AACAF,MAAAA,EAAE,CAAE,iBAAF,CAAF;AACD,KAHD,MAGO;AACLA,MAAAA,EAAE,CAAC,IAAD,EAAOE,GAAP,CAAF;AACD;AACF,GAxBkB;AAyBnBhB,EAAAA,KAAK,EAAEI,eAAe,EAzBH,CA4BrB;AACA;;AA7BqB,CAArB;;AA8BA,IAAIsB,OAAO,CAACC,GAAR,CAAYC,wBAAZ,KAA0C,OAA9C,EAAsD;AACpD,SAAOnB,YAAY,CAACc,MAApB;AACA,SAAOd,YAAY,CAACM,QAApB;AACA,SAAON,YAAY,CAACE,KAApB;AACD;;AAED,MAAMkB,KAAK,GAAG,IAAIhC,KAAJ,CAAU,CAACiC,KAAD,EAAQC,QAAR,KAAqB;AAC3C,QAAMC,KAAK,GAAGhC,KAAK,CAACiC,QAAN,EAAd;AACA5B,EAAAA,UAAU,CAAC6B,GAAX,CAAeJ,KAAK,CAACT,EAArB;AAEA,SAAOtB,WAAW,CAAC+B,KAAD,EAAQE,KAAK,CAACG,UAAN,CAAiBL,KAAK,CAACM,SAAvB,CAAR,CAAX,CACJC,KADI,CACEC,CAAC,IAAIC,OAAO,CAACC,GAAR,CAAa,2BAAb,EAAyCF,CAAzC,CADP,EAEJG,IAFI,CAGHC,MAAM,IAAI;AACRrC,IAAAA,UAAU,CAACsC,MAAX,CAAkBb,KAAK,CAACT,EAAxB;;AACA,QAAId,OAAO,CAACiB,GAAR,CAAYM,KAAK,CAACT,EAAlB,CAAJ,EAA2B;AACzBQ,MAAAA,KAAK,CAACe,IAAN,CAAWrC,OAAO,CAACsC,GAAR,CAAYf,KAAK,CAACT,EAAlB,CAAX;AACAd,MAAAA,OAAO,CAACoC,MAAR,CAAeb,KAAK,CAACT,EAArB;AACD,KALO,CAOR;;;AACAnB,IAAAA,mBAAmB,CAAC4C,YAApB,CAAiC;AAC/BC,MAAAA,IAAI,EAAEjB,KAAK,CAACT,EADmB;AAE/B2B,MAAAA,aAAa,EAAElB,KAAK,CAACkB,aAFU;AAG/BC,MAAAA,MAAM,EAAEnB,KAAK,CAACmB;AAHiB,KAAjC;AAMA,WAAOlB,QAAQ,CAAC,IAAD,EAAOW,MAAP,CAAf;AACD,GAlBE,EAmBHQ,KAAK,IAAInB,QAAQ,CAACmB,KAAD,CAnBd,CAAP;AAqBD,CAzBa,EAyBXzC,YAzBW,CAAd,C,CA2BA;AACA;;AACA,IAAI0C,eAAe,GAAG,IAAtB;AACAtB,KAAK,CAACuB,KAAN;AAEAnD,OAAO,CAACoD,EAAR,CAAY,mBAAZ,EAAgC,MAAM;AACpCF,EAAAA,eAAe,GAAG,KAAlB;AACAtB,EAAAA,KAAK,CAACyB,MAAN;AACD,CAHD,E,CAIA;AAEA;;AACArD,OAAO,CAACoD,EAAR,CAAY,aAAZ,EAA0B,MAAM;AAC9BxB,EAAAA,KAAK,CAACuB,KAAN;AACD,CAFD,E,CAIA;;AACAnD,OAAO,CAACoD,EAAR,CAAY,yBAAZ,EAAsC,MAAM;AAC1C,MAAI,CAACF,eAAL,EAAsB;AACpBtB,IAAAA,KAAK,CAACyB,MAAN;AACD;AACF,CAJD;AAMAzB,KAAK,CAACwB,EAAN,CAAU,OAAV,EAAkB,MAAM;AACtBpD,EAAAA,OAAO,CAACsD,IAAR,CAAc,qBAAd;AACD,CAFD;AAIA1B,KAAK,CAACwB,EAAN,CAAU,aAAV,EAAwB,MAAM;AAC5BpD,EAAAA,OAAO,CAACsD,IAAR,CAAc,gBAAd;AACD,CAFD;AAIAC,MAAM,CAACC,OAAP,GAAiB5B,KAAjB","sourcesContent":["const Queue = require(`better-queue`)\n\nconst queryRunner = require(`./query-runner`)\nconst { store, emitter } = require(`../../redux`)\nconst { boundActionCreators } = require(`../../redux/actions`)\nconst websocketManager = require(`../../utils/websocket-manager`)\nconst FastMemoryStore = require(`./better-queue-custom-store`)\n\nconst processing = new Set()\nconst waiting = new Map()\n\nconst queueOptions = {\n  concurrent: 4,\n  // Merge duplicate jobs.\n  merge: (oldTask, newTask, cb) => {\n    cb(null, newTask)\n  },\n  priority: (job, cb) => {\n    const activePaths = Array.from(websocketManager.activePaths.values())\n    if (job.id && activePaths.includes(job.id)) {\n      cb(null, 10)\n    } else {\n      cb(null, 1)\n    }\n  },\n  // Filter out new query jobs if that query is already running.  When the\n  // query finshes, it checks the waiting map and pushes another job to\n  // make sure all the user changes are captured.\n  filter: (job, cb) => {\n    if (processing.has(job.id)) {\n      waiting.set(job.id, job)\n      cb(`already running`)\n    } else {\n      cb(null, job)\n    }\n  },\n  store: FastMemoryStore(),\n}\n\n// During builds we don't need all the filtering, etc. so we\n// remove them to speed up queries\nif (process.env.gatsby_executing_command === `build`) {\n  delete queueOptions.filter\n  delete queueOptions.priority\n  delete queueOptions.merge\n}\n\nconst queue = new Queue((plObj, callback) => {\n  const state = store.getState()\n  processing.add(plObj.id)\n\n  return queryRunner(plObj, state.components[plObj.component])\n    .catch(e => console.log(`Error running queryRunner`, e))\n    .then(\n      result => {\n        processing.delete(plObj.id)\n        if (waiting.has(plObj.id)) {\n          queue.push(waiting.get(plObj.id))\n          waiting.delete(plObj.id)\n        }\n\n        // Send event that the page query finished.\n        boundActionCreators.pageQueryRun({\n          path: plObj.id,\n          componentPath: plObj.componentPath,\n          isPage: plObj.isPage,\n        })\n\n        return callback(null, result)\n      },\n      error => callback(error)\n    )\n}, queueOptions)\n\n// HACKY!!! TODO: REMOVE IN NEXT REFACTOR\n// We start paused until we call `runInitialQueries` during bootstrap.\nlet isBootstrapping = true\nqueue.pause()\n\nemitter.on(`START_QUERY_QUEUE`, () => {\n  isBootstrapping = false\n  queue.resume()\n})\n// END HACKY\n\n// Pause running queries when new nodes are added (processing starts).\nemitter.on(`CREATE_NODE`, () => {\n  queue.pause()\n})\n\n// Resume running queries as soon as the api queue is empty.\nemitter.on(`API_RUNNING_QUEUE_EMPTY`, () => {\n  if (!isBootstrapping) {\n    queue.resume()\n  }\n})\n\nqueue.on(`drain`, () => {\n  emitter.emit(`QUERY_QUEUE_DRAINED`)\n})\n\nqueue.on(`task_queued`, () => {\n  emitter.emit(`QUERY_ENQUEUED`)\n})\n\nmodule.exports = queue\n"],"file":"query-queue.js"}