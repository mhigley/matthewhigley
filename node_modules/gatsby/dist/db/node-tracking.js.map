{"version":3,"sources":["../../src/db/node-tracking.js"],"names":["_","require","rootNodeMap","WeakMap","getRootNodeId","node","get","addRootNodeToInlineObject","data","nodeId","isPlainObject","isArray","each","o","set","trackInlineObjectsInRootNode","v","k","id","exports","findRootNodeAncestor","obj","predicate","getNode","rootNode","whileCount","rootNodeId","parent","undefined","console","log","trackDbNodes","getNodes"],"mappings":";;AAAA,MAAMA,CAAC,GAAGC,OAAO,CAAE,QAAF,CAAjB;AAEA;;;;;;;AAKA,MAAMC,WAAW,GAAG,IAAIC,OAAJ,EAApB;;AAEA,MAAMC,aAAa,GAAGC,IAAI,IAAIH,WAAW,CAACI,GAAZ,CAAgBD,IAAhB,CAA9B;AAEA;;;;;;;;;AAOA,MAAME,yBAAyB,GAAG,CAACC,IAAD,EAAOC,MAAP,KAAkB;AAClD,MAAIT,CAAC,CAACU,aAAF,CAAgBF,IAAhB,KAAyBR,CAAC,CAACW,OAAF,CAAUH,IAAV,CAA7B,EAA8C;AAC5CR,IAAAA,CAAC,CAACY,IAAF,CAAOJ,IAAP,EAAaK,CAAC,IAAIN,yBAAyB,CAACM,CAAD,EAAIJ,MAAJ,CAA3C;;AACAP,IAAAA,WAAW,CAACY,GAAZ,CAAgBN,IAAhB,EAAsBC,MAAtB;AACD;AACF,CALD;AAOA;;;;;;;AAKA,MAAMM,4BAA4B,GAAGV,IAAI,IAAI;AAC3CL,EAAAA,CAAC,CAACY,IAAF,CAAOP,IAAP,EAAa,CAACW,CAAD,EAAIC,CAAJ,KAAU;AACrB;AACA,QAAIA,CAAC,KAAM,UAAX,EAAsB;AACpB;AACD;;AACDV,IAAAA,yBAAyB,CAACS,CAAD,EAAIX,IAAI,CAACa,EAAT,CAAzB;AACD,GAND;;AAQA,SAAOb,IAAP;AACD,CAVD;;AAWAc,OAAO,CAACJ,4BAAR,GAAuCA,4BAAvC;AAEA;;;;;;;;AAOA,MAAMK,oBAAoB,GAAG,CAACC,GAAD,EAAMC,SAAS,GAAG,IAAlB,KAA2B;AAAA,mBAClCrB,OAAO,CAAE,SAAF,CAD2B;AAAA,QAC9CsB,OAD8C,YAC9CA,OAD8C,EAGtD;;;AACA,MAAIC,QAAQ,GAAGH,GAAf;AACA,MAAII,UAAU,GAAG,CAAjB;AACA,MAAIC,UAAJ;;AACA,SACE,CAAC,CAACJ,SAAD,IAAc,CAACA,SAAS,CAACE,QAAD,CAAzB,MACCE,UAAU,GAAGtB,aAAa,CAACoB,QAAD,CAAb,IAA2BA,QAAQ,CAACG,MADlD,MAEEH,QAAQ,CAACG,MAAT,IAAmBJ,OAAO,CAACC,QAAQ,CAACG,MAAV,CAAP,KAA6BC,SAAjD,IACCL,OAAO,CAACG,UAAD,CAHT,KAIAD,UAAU,GAAG,GALf,EAME;AACA,QAAIC,UAAJ,EAAgB;AACdF,MAAAA,QAAQ,GAAGD,OAAO,CAACG,UAAD,CAAlB;AACD,KAFD,MAEO;AACLF,MAAAA,QAAQ,GAAGD,OAAO,CAACC,QAAQ,CAACG,MAAV,CAAlB;AACD;;AACDF,IAAAA,UAAU,IAAI,CAAd;;AACA,QAAIA,UAAU,GAAG,GAAjB,EAAsB;AACpBI,MAAAA,OAAO,CAACC,GAAR,CACG,+DADH,EAEEN,QAFF;AAID;AACF;;AAED,SAAO,CAACF,SAAD,IAAcA,SAAS,CAACE,QAAD,CAAvB,GAAoCA,QAApC,GAA+C,IAAtD;AACD,CA7BD;;AA+BA,SAASO,YAAT,GAAwB;AAAA,oBACD9B,OAAO,CAAE,SAAF,CADN;AAAA,QACd+B,QADc,aACdA,QADc;;AAEtBhC,EAAAA,CAAC,CAACY,IAAF,CAAOoB,QAAQ,EAAf,EAAmB3B,IAAI,IAAI;AACzBU,IAAAA,4BAA4B,CAACV,IAAD,CAA5B;AACD,GAFD;AAGD;AAED;;;;;;AAIAc,OAAO,CAACC,oBAAR,GAA+BA,oBAA/B;AACAD,OAAO,CAACY,YAAR,GAAuBA,YAAvB","sourcesContent":["const _ = require(`lodash`)\n\n/**\n * Map containing links between inline objects or arrays\n * and Node that contains them\n * @type {Object.<(Object|Array),string>}\n */\nconst rootNodeMap = new WeakMap()\n\nconst getRootNodeId = node => rootNodeMap.get(node)\n\n/**\n * Add link between passed data and Node. This function shouldn't be used\n * directly. Use higher level `trackInlineObjectsInRootNode`\n * @see trackInlineObjectsInRootNode\n * @param {(Object|Array)} data Inline object or array\n * @param {string} nodeId Id of node that contains data passed in first parameter\n */\nconst addRootNodeToInlineObject = (data, nodeId) => {\n  if (_.isPlainObject(data) || _.isArray(data)) {\n    _.each(data, o => addRootNodeToInlineObject(o, nodeId))\n    rootNodeMap.set(data, nodeId)\n  }\n}\n\n/**\n * Adds link between inline objects/arrays contained in Node object\n * and that Node object.\n * @param {Node} node Root Node\n */\nconst trackInlineObjectsInRootNode = node => {\n  _.each(node, (v, k) => {\n    // Ignore the node internal object.\n    if (k === `internal`) {\n      return\n    }\n    addRootNodeToInlineObject(v, node.id)\n  })\n\n  return node\n}\nexports.trackInlineObjectsInRootNode = trackInlineObjectsInRootNode\n\n/**\n * Finds top most ancestor of node that contains passed Object or Array\n * @param {(Object|Array)} obj Object/Array belonging to Node object or Node object\n * @param {nodePredicate} [predicate] Optional callback to check if ancestor meets defined conditions\n * @returns {Node} Top most ancestor if predicate is not specified\n * or first node that meet predicate conditions if predicate is specified\n */\nconst findRootNodeAncestor = (obj, predicate = null) => {\n  const { getNode } = require(`./nodes`)\n\n  // Find the root node.\n  let rootNode = obj\n  let whileCount = 0\n  let rootNodeId\n  while (\n    (!predicate || !predicate(rootNode)) &&\n    (rootNodeId = getRootNodeId(rootNode) || rootNode.parent) &&\n    ((rootNode.parent && getNode(rootNode.parent) !== undefined) ||\n      getNode(rootNodeId)) &&\n    whileCount < 101\n  ) {\n    if (rootNodeId) {\n      rootNode = getNode(rootNodeId)\n    } else {\n      rootNode = getNode(rootNode.parent)\n    }\n    whileCount += 1\n    if (whileCount > 100) {\n      console.log(\n        `It looks like you have a node that's set its parent as itself`,\n        rootNode\n      )\n    }\n  }\n\n  return !predicate || predicate(rootNode) ? rootNode : null\n}\n\nfunction trackDbNodes() {\n  const { getNodes } = require(`./nodes`)\n  _.each(getNodes(), node => {\n    trackInlineObjectsInRootNode(node)\n  })\n}\n\n/**\n * @callback nodePredicate\n * @param {Node} node Node that is examined\n */\nexports.findRootNodeAncestor = findRootNodeAncestor\nexports.trackDbNodes = trackDbNodes\n"],"file":"node-tracking.js"}